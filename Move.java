

import java.util.StringTokenizer;
import java.util.Vector;

/**
 * Encapsulates a move
 * 
 * In general, you should regard this as an opaque structure that exists in the
 * GameState you obtain from FindPossibleMoves.
 * 
 * The functions IsNormal(), IsJump() and IsEOG(), might be useful.
 * 
 * You can probably ignore the rest of the class interface.
 */
public class Move {
	static final String cDelimiter = "_";

	private int mType;
	private Vector<Integer> mData = new Vector<Integer>();

	/**
	 * constructs a special type move
	 * 
	 * @param pType
	 *            pType should be one of MOVE_BOG, MOVE_RW, MOVE_WW or MOVE_DRAW
	 * @return
	 */
	public Move(MoveType pType) {
		this.mType = pType.getInternalValue();
	} // End constructor Move

	/**
	 * Constructs a MOVE_BOG move.
	 */
	public Move() {
		this(MoveType.MOVE_BOG);
	} // End constructor Move

	/**
	 * constructs a normal move (not a jump)
	 * 
	 * @param p1
	 *            the source square
	 * @param p2
	 *            the destination square
	 */
	public Move(int p1, int p2) {
		this(MoveType.MOVE_NORMAL);

		assert (this.mData.size() == 0);

		this.mData.add(p1);
		this.mData.add(p2);
	} // End constructor Move

	/**
	 * Constructs a jump move
	 * 
	 * @param pData
	 *            a series of squares that form the sequence of jumps
	 */
	public Move(Vector<Integer> pData, int len) {
		this.mType = len - 1;
        this.mData.setSize(0);
        for (int i = 0; i < len; i++) {
            this.mData.add(pData.get(i));
        }
	} // End constructor Move

	/**
	 * reconstructs the move from a string
	 * 
	 * @param \param pString a string, which should have been previously
	 *        generated by ToMessage(), or obtained from the server.
	 */
	public Move(final String pString) {
		StringTokenizer st = new StringTokenizer(pString, Move.cDelimiter);
		String str = st.nextToken();

		this.mType = Integer.parseInt(str);

		int lLen = 0;

		if (mType == MoveType.MOVE_NORMAL.getInternalValue()) {
			lLen = 2;
		} else if (mType > 0) {
			lLen = mType + 1;
		} // End if

		if (lLen > 12 || mType < MoveType.MOVE_NULL.getInternalValue()) {
			mType = MoveType.MOVE_NULL.getInternalValue();
			return;
		} // End if

		this.mData.setSize(lLen);

		for (int i = 0; i < lLen; i++) {
			int lCell;

			str = st.nextToken();
			lCell = Integer.parseInt(str);

			if (lCell < 1 || lCell > 32) {
				this.mType = MoveType.MOVE_NULL.getInternalValue();
				break;
			} // End if

			this.mData.set(i, lCell);
		} // End for

		if (st.hasMoreTokens()) {
			this.mType = MoveType.MOVE_NULL.getInternalValue();
		} // End if
	} // End constructor Move

	/**
	 * @return A reverse version of this move
	 */
	Move reversed() {
		Move result = this;

		if (this.isRedWin()) {
			result.mType = MoveType.MOVE_WW.getInternalValue();
		} else if (this.isWhiteWin()) {
			result.mType = MoveType.MOVE_RW.getInternalValue();
		} // End else

		for (int i = 0; i < this.mData.size(); i++) {
			result.mData.set(i, 33 - this.mData.elementAt(i));
		} // End for
		return result;
	} // End reversed

	/**
	 * @return true if the movement is null or invalid
	 */
	boolean isNull() {
		return (this.mType == MoveType.MOVE_NULL.getInternalValue());
	} // End isNull

	/**
	 * @return true if the movement marks beginning of game
	 */
	boolean isBOG() {
		return (this.mType == MoveType.MOVE_BOG.getInternalValue());
	} // End isBOG

	/**
	 * @return true if the movement marks end of game
	 */
	public boolean isEOG() {
		return (this.mType < MoveType.MOVE_BOG.getInternalValue());
	} // End isEOG

	/**
	 * @return true if the game ended in red win
	 */
	public boolean isRedWin() {
		return (this.mType == MoveType.MOVE_RW.getInternalValue());
	} // End isRedWin

	/**
	 * @return true if the game ended in white win
	 */
	public boolean isWhiteWin() {
		return (this.mType == MoveType.MOVE_WW.getInternalValue());
	} // End isWhiteWin

	/**
	 * @return true if the game ended in draw
	 */
	public boolean isDraw() {
		return (this.mType == MoveType.MOVE_DRAW.getInternalValue());
	} // End isDraw

	/**
	 * @return true if the movement is a jump
	 */
	public boolean isJump() {
		return (this.mType > 0);
	} // End isJump

	/**
	 * @returns true if the movement is a normal move
	 */
	public boolean isNormal() {
		return (this.mType == MoveType.MOVE_NORMAL.getInternalValue());
	} // End isNormal

	/**
	 * @returns the type of the move
	 */
	public int getType() {
		return this.mType;
	} // End getType

	/**
	 * @return (for normal moves and jumps) the number of squares
	 */
	public int length() {
		return this.mData.size();
	} // End length

	/**
	 * @return the pN-th square in the sequence
	 */
	public int at(int pN) {
		return this.mData.elementAt(pN);
	} // End at

	/**
	 * converts the move to a string so that it can be sent to the other player
	 */
	public String toMessage() {
		String lStream = new String();
		lStream = lStream + mType;

		for (int i = 0; i < this.mData.size(); i++) {
			lStream = lStream + cDelimiter + this.mData.elementAt(i);
		} // End for

		return lStream;
	} // End toMessage

	/**
	 * converts the move to a human readable string so that it can be printed
	 */
	public String toString() {
		if (this.mType == MoveType.MOVE_WW.getInternalValue()) {
			return "WW";
		} // End if
		if (this.mType == MoveType.MOVE_RW.getInternalValue()) {
			return "RW";
		} // End if
		if (this.mType == MoveType.MOVE_DRAW.getInternalValue()) {
			return "DRAW";
		} // End if
		if (this.mType == MoveType.MOVE_BOG.getInternalValue()) {
			return "BOG";
		} // End if
		if (this.isNull()) {
			return "NULL";
		} // End if

		String lStream = new String();
		String delimiter = isNormal() ? "-" : "x";

		assert (this.mData.size() > 0);

		// Concatenate all the cell numbers
		lStream = lStream + this.mData.elementAt(0);

		for (int i = 1; i < this.mData.size(); i++) {
			lStream = lStream + delimiter + this.mData.elementAt(i);
		} // End for

		return lStream;
	}

	/**
	 * @return true if the two objects represent the same move
	 */
	public boolean equals(final Move pRH) {
		if (this.mType != pRH.mType) {
			return false;
		} // End if

		if (this.mData.size() != pRH.mData.size()) {
			return false;
		} // End if

		for (int i = 0; i < this.mData.size(); i++) {
			if (this.mData.elementAt(i) != pRH.mData.elementAt(i)) {
				return false;
			} // End if
		} // End for

		return true;
	} // End equals

	/**
	 * Encapsulated type for moves.
	 * 
	 */
	public enum MoveType {
		MOVE_JUMP(1),   	// / a single jump (numbers above that will represent
						// multiple jumps)
		MOVE_NORMAL(0), 	// / a normal move
		MOVE_BOG(-1),   	// / beginning of game
		MOVE_RW(-2),   		// / red wins => end of game
		MOVE_WW(-3),   		// / white wins => end of game
		MOVE_DRAW(-4),   	// / draw => end of game
		MOVE_NULL(-5);   	// / a null move

		private int internalValue;

		MoveType(int pValue) {
			this.internalValue = pValue;
		} // End constructor MoveType

		public int getInternalValue() {
			return this.internalValue;
		} // End getInternalValue
	} // End MoveType
} // End class Move
